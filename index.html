<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Stickman Spider Swing - Improved Physics & Score</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: linear-gradient(to top, #001022 0%, #87ceeb 100%);
    font-family: Arial, sans-serif;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }
  canvas {
    display: block;
    background: transparent;
    touch-action: none;
  }
  #score {
    position: absolute;
    top: 20px;
    left: 20px;
    color: white;
    font-size: 28px;
    font-weight: bold;
    text-shadow: 0 0 5px #000;
    user-select: none;
    pointer-events: none;
  }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<canvas id="game"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  // Constants
  const gravity = 0.6;
  const ropeLength = 300;
  const maxAngularVelocity = 0.2;
  const swingForce = 0.0012;
  const friction = 0.995;

  // State
  let isSwinging = true;
  let isHolding = false;

  // Rope anchor point fixed top center-ish
  let anchor = {
    x: canvas.width / 3,
    y: 150,
  };

  // Spiderman pendulum state
  let angle = Math.PI / 4; // pendulum angle from vertical (radians)
  let angularVelocity = 0;
  let angularAcceleration = 0;

  // Position of spider
  let spider = {
    x: anchor.x + ropeLength * Math.sin(angle),
    y: anchor.y + ropeLength * Math.cos(angle),
    radius: 20,
    vx: 0,
    vy: 0,
  };

  // Score and camera
  let score = 0;
  let cameraX = 0;

  // Input handlers
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (isSwinging) isHolding = true;
  });
  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if (isSwinging) {
      isHolding = false;
      isSwinging = false;
      // Convert angular velocity to linear velocity on release
      spider.vx = angularVelocity * ropeLength * Math.cos(angle + Math.PI / 2);
      spider.vy = angularVelocity * ropeLength * Math.sin(angle + Math.PI / 2);
    }
  });

  // Mouse fallback
  canvas.addEventListener('mousedown', e => {
    if (isSwinging) isHolding = true;
  });
  canvas.addEventListener('mouseup', e => {
    if (isSwinging) {
      isHolding = false;
      isSwinging = false;
      spider.vx = angularVelocity * ropeLength * Math.cos(angle + Math.PI / 2);
      spider.vy = angularVelocity * ropeLength * Math.sin(angle + Math.PI / 2);
    }
  });

  function reset() {
    angle = Math.PI / 4;
    angularVelocity = 0;
    angularAcceleration = 0;
    spider.x = anchor.x + ropeLength * Math.sin(angle);
    spider.y = anchor.y + ropeLength * Math.cos(angle);
    spider.vx = 0;
    spider.vy = 0;
    isSwinging = true;
    isHolding = false;
    score = 0;
    cameraX = 0;
  }

  function update() {
    if (isSwinging) {
      // Pendulum physics: angular acceleration = (-g / L) * sin(theta)
      angularAcceleration = (-gravity / ropeLength) * Math.sin(angle);

      // If holding, apply force in direction of swing to gain momentum
      if (isHolding) {
        angularAcceleration += swingForce * (angularVelocity > 0 ? 1 : -1);
      }

      angularVelocity += angularAcceleration;
      angularVelocity *= friction; // damping friction
      // Clamp velocity for smoothness
      if (angularVelocity > maxAngularVelocity) angularVelocity = maxAngularVelocity;
      if (angularVelocity < -maxAngularVelocity) angularVelocity = -maxAngularVelocity;

      angle += angularVelocity;

      spider.x = anchor.x + ropeLength * Math.sin(angle);
      spider.y = anchor.y + ropeLength * Math.cos(angle);

      // Score increases by horizontal distance traveled forward (relative to camera)
      const distanceTravelled = spider.x - cameraX;
      if (distanceTravelled > score) {
        score = Math.floor(distanceTravelled);
      }
    } else {
      // In flight
      spider.vy += gravity;
      spider.x += spider.vx;
      spider.y += spider.vy;

      // Camera follows spider smoothly
      cameraX += (spider.x - cameraX - 150) * 0.1;

      // Check if spider is close enough to grab next rope point automatically
      // For this demo: rope point is fixed but we allow "re-swing" when close horizontally and below anchor
      if (spider.y > anchor.y && Math.abs(spider.x - anchor.x) < ropeLength + 50) {
        isSwinging = true;
        angle = Math.atan2(spider.x - anchor.x, spider.y - anchor.y);
        angularVelocity = spider.vx * 0.02; // initial angular velocity from flight vx
        spider.vx = 0;
        spider.vy = 0;
      }

      // Reset if falls off screen
      if (spider.y > canvas.height + 100) {
        reset();
      }
    }
  }

  function drawSpider(x, y) {
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';

    // Head - red circle
    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.arc(x, y - 40, 15, 0, Math.PI * 2);
    ctx.fill();

    // Body - black line
    ctx.beginPath();
    ctx.moveTo(x, y - 25);
    ctx.lineTo(x, y + 20);
    ctx.stroke();

    // Arms
    ctx.beginPath();
    ctx.moveTo(x, y - 10);
    ctx.lineTo(x - 25, y + 10);
    ctx.moveTo(x, y - 10);
    ctx.lineTo(x + 25, y + 10);
    ctx.stroke();

    // Legs
    ctx.beginPath();
    ctx.moveTo(x, y + 20);
    ctx.lineTo(x - 20, y + 50);
    ctx.moveTo(x, y + 20);
    ctx.lineTo(x + 20, y + 50);
    ctx.stroke();

    // Eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(x - 6, y - 44, 5, 8, 0.2, 0, Math.PI * 2);
    ctx.ellipse(x + 6, y - 44, 5, 8, -0.2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(x - 6, y - 44, 2.5, 4.5, 0.2, 0, Math.PI * 2);
    ctx.ellipse(x + 6, y - 44, 2.5, 4.5, -0.2, 0, Math.PI * 2);
    ctx.fill();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw rope line
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(anchor.x - cameraX, anchor.y);
    ctx.lineTo(spider.x - cameraX, spider.y);
    ctx.stroke();

    // Draw spider stickman
    drawSpider(spider.x - cameraX, spider.y);

    // Draw ground line
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-1000 - cameraX, canvas.height - 10);
    ctx.lineTo(10000 - cameraX, canvas.height - 10);
    ctx.stroke();
  }

  function loop() {
    update();
    draw();
    scoreEl.textContent = 'Score: ' + score;
    requestAnimationFrame(loop);
  }

  reset();
  loop();
})();
</script>
</body>
</html>
