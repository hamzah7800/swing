<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Smooth Spider Swing</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: linear-gradient(to top, #001022, #87ceeb);
    font-family: sans-serif;
    touch-action: none;
  }
  canvas {
    display: block;
    background: transparent;
  }
  #score {
    position: absolute;
    top: 15px;
    left: 20px;
    font-size: 24px;
    color: #fff;
    font-weight: bold;
    text-shadow: 1px 1px 2px #000;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="score">Score: 0</div>
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let W = window.innerWidth, H = window.innerHeight;
canvas.width = W;
canvas.height = H;

let score = 0;
const scoreEl = document.getElementById("score");

// Rope physics
const ropeLength = 280;
let angle = Math.PI / 3; // 60 degrees
let angularVelocity = 0;
let angularAcceleration = 0;
const gravity = 0.5;
const damping = 0.995;
const swingBoost = 0.0012;

// Spider
let spider = { x: 0, y: 0, radius: 18, vx: 0, vy: 0 };

// Anchor points
let anchors = [];
let anchorIndex = 0;
let isSwinging = true;
let isHolding = false;
let cameraX = 0;

// Create anchors
function generateAnchors() {
  anchors = [];
  let x = 100;
  for (let i = 0; i < 50; i++) {
    let height = 150 + Math.random() * 200;
    anchors.push({ x, y: H - height });
    x += 200 + Math.random() * 200;
  }
}
generateAnchors();

function getAnchor() {
  return anchors[anchorIndex];
}

function updateSpiderPosFromAngle() {
  const a = getAnchor();
  const stretch = 1 + 0.05 * Math.sin(Date.now() / 200); // stretchy rope
  spider.x = a.x + ropeLength * stretch * Math.sin(angle);
  spider.y = a.y + ropeLength * stretch * Math.cos(angle);
}

function resetGame() {
  anchorIndex = 0;
  angle = Math.PI / 3;
  angularVelocity = 0;
  isSwinging = true;
  isHolding = false;
  updateSpiderPosFromAngle();
  spider.vx = 0;
  spider.vy = 0;
  cameraX = 0;
  score = 0;
}

function update() {
  const anchor = getAnchor();

  if (isSwinging) {
    angularAcceleration = (-gravity / ropeLength) * Math.sin(angle);
    if (isHolding) {
      angularAcceleration += swingBoost * (angularVelocity > 0 ? 1 : -1);
    }
    angularVelocity += angularAcceleration;
    angularVelocity *= damping;
    angle += angularVelocity;
    updateSpiderPosFromAngle();
    if (spider.x - cameraX > score) {
      score = Math.floor(spider.x - cameraX);
    }
  } else {
    spider.vy += gravity;
    spider.x += spider.vx;
    spider.y += spider.vy;

    cameraX += (spider.x - cameraX - 150) * 0.05;

    // Auto-latch
    for (let i = anchorIndex + 1; i < anchors.length; i++) {
      let a = anchors[i];
      let dx = spider.x - a.x;
      let dy = spider.y - a.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 60) {
        anchorIndex = i;
        angle = Math.atan2(dx, dy);
        angularVelocity = spider.vx * 0.02;
        isSwinging = true;
        spider.vx = 0;
        spider.vy = 0;
        return;
      }
    }

    if (spider.y > H + 150 || spider.x < cameraX - 200) {
      resetGame();
    }
  }
}

function drawSpider(x, y) {
  ctx.lineWidth = 4;
  ctx.strokeStyle = "#000";
  ctx.fillStyle = "#ff2020";

  // Head
  ctx.beginPath();
  ctx.arc(x, y - 20, 12, 0, 2 * Math.PI);
  ctx.fill();
  ctx.stroke();

  // Body
  ctx.beginPath();
  ctx.moveTo(x, y - 10);
  ctx.lineTo(x, y + 20);
  ctx.stroke();

  // Arms
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x - 20, y + 10);
  ctx.moveTo(x, y);
  ctx.lineTo(x + 20, y + 10);
  ctx.stroke();

  // Legs
  ctx.beginPath();
  ctx.moveTo(x, y + 20);
  ctx.lineTo(x - 15, y + 40);
  ctx.moveTo(x, y + 20);
  ctx.lineTo(x + 15, y + 40);
  ctx.stroke();
}

function drawRope() {
  const anchor = getAnchor();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#fff";
  ctx.beginPath();
  ctx.moveTo(anchor.x - cameraX, anchor.y);
  ctx.lineTo(spider.x - cameraX, spider.y);
  ctx.stroke();
}

function draw() {
  ctx.clearRect(0, 0, W, H);

  // Anchors
  ctx.fillStyle = "#333";
  anchors.forEach(a => {
    ctx.fillRect(a.x - 10 - cameraX, a.y, 20, H - a.y);
  });

  // Rope
  if (isSwinging) drawRope();

  // Spider
  drawSpider(spider.x - cameraX, spider.y);

  scoreEl.innerText = "Score: " + score;
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// Touch controls
canvas.addEventListener("touchstart", e => {
  if (isSwinging) isHolding = true;
});
canvas.addEventListener("touchend", e => {
  if (isSwinging) {
    isHolding = false;
    isSwinging = false;
    spider.vx = angularVelocity * ropeLength * Math.cos(angle + Math.PI / 2);
    spider.vy = angularVelocity * ropeLength * Math.sin(angle + Math.PI / 2);
  }
});

// Mouse fallback
canvas.addEventListener("mousedown", () => { if (isSwinging) isHolding = true; });
canvas.addEventListener("mouseup", () => {
  if (isSwinging) {
    isHolding = false;
    isSwinging = false;
    spider.vx = angularVelocity * ropeLength * Math.cos(angle + Math.PI / 2);
    spider.vy = angularVelocity * ropeLength * Math.sin(angle + Math.PI / 2);
  }
});

resetGame();
loop();
</script>
</body>
</html>
