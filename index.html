<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Stickman Swinger</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
  html, body {
    margin:0; padding:0; overflow:hidden;
    background: linear-gradient(to top, #001830, #87ceeb);
    touch-action: none;
  }
  canvas { display:block; }
  #score {
    position:absolute; top:20px; left:20px;
    font-size:24px; color:white;
    text-shadow:2px 2px 4px #000;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="score">Score: 0</div>
<audio id="whoosh" src="https://freesound.org/data/previews/256/256113_3263906-lq.mp3"></audio>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let W = innerWidth, H = innerHeight;
canvas.width = W; canvas.height = H;

const whoosh = document.getElementById("whoosh");

// Buildings
const skyline = [];
for(let i=0; i<20; i++){
  const w = 100 + Math.random()*100;
  const h = 200 + Math.random()*150;
  skyline.push({x: i*w*1.5, y: H - h - 50, w, h});
}

// Clouds
const clouds = [];
for(let i=0; i<10; i++){
  clouds.push({
    x: Math.random()*W,
    y: 50 + Math.random()*150,
    w: 80 + Math.random()*60,
    speed: 0.2 + Math.random()*0.3
  });
}

let ropeLength = 300, angle = Math.PI/3, angularVelocity=0, angularAcceleration=0;
const gravity = 0.4, damping=0.992, swingBoost=0.001;
let spider = {x:0,y:0,vx:0,vy:0,radius:18};
let anchors = [], anchorIndex=0;
let isSwinging=true, isHolding=false, cameraX=0;
let score=0, scoreOffset = 0;
const scoreEl = document.getElementById("score");

// Particles
let particles = [];
function createLatchParticles(x, y) {
  for(let i=0; i<15; i++){
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      alpha: 1
    });
  }
}
function updateParticles() {
  particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.alpha -= 0.03;
  });
  particles = particles.filter(p => p.alpha > 0);
}
function drawParticles() {
  ctx.fillStyle = "white";
  particles.forEach(p => {
    ctx.globalAlpha = p.alpha;
    ctx.beginPath();
    ctx.arc(p.x - cameraX, p.y, 3, 0, 2 * Math.PI);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

// Anchors
function generateAnchors(){
  anchors=[];
  let x=150;
  for(let i=0;i<60;i++){
    const height = 200 + Math.random()*250;
    anchors.push({x,y:H-height});
    x += 250 + Math.random()*200;
  }
}
generateAnchors();

function getAnchor(){return anchors[anchorIndex];}
function updateSpiderPosFromAngle(){
  const a=getAnchor();
  spider.x = a.x + ropeLength*Math.sin(angle);
  spider.y = a.y + ropeLength*Math.cos(angle);
}
function resetGame(){
  anchorIndex=0; angle=Math.PI/3; angularVelocity=0;
  isSwinging= true; isHolding=false; updateSpiderPosFromAngle();
  spider.vx=0; spider.vy=0; cameraX=0;
  scoreOffset = Math.floor(spider.x);
  score = 0;
}
function findNearestAnchor(){
  let nearest=null, minDist=1e9;
  anchors.forEach((a,i)=>{
    const dx=spider.x-a.x, dy=spider.y-a.y;
    const dist=Math.hypot(dx,dy);
    if(dist<minDist && i>anchorIndex){
      minDist=dist; nearest={anchor:a, index:i, dist};
    }
  });
  return nearest;
}
function playWhoosh(){
  whoosh.currentTime = 0;
  whoosh.play();
}

function update(){
  const anchor=getAnchor();
  if(isSwinging){
    angularAcceleration = (-gravity/ropeLength)*Math.sin(angle);
    if(isHolding) angularAcceleration += swingBoost*(angularVelocity>0?1:-1);
    angularVelocity += angularAcceleration;
    angularVelocity *= damping;
    angle += angularVelocity;
    updateSpiderPosFromAngle();

    const dist = Math.hypot(spider.x - anchor.x, spider.y - anchor.y);
    if (dist > ropeLength + 10) angularVelocity *= -0.2;

    score = Math.floor(spider.x - cameraX - scoreOffset);
  } else {
    spider.vy += gravity;
    spider.x += spider.vx;
    spider.y += spider.vy;
    cameraX += (spider.x - cameraX - 150)*0.05;

    if(spider.y > H+200 || spider.x < cameraX-200) resetGame();

    const near = findNearestAnchor();
    if(near && near.dist < 160){
      const dx = near.anchor.x - spider.x;
      const dy = near.anchor.y - spider.y;
      spider.vx += dx * 0.0015;
      spider.vy += dy * 0.0015;
    }
  }

  clouds.forEach(cl=>{
    cl.x += cl.speed;
    if(cl.x > W+50) cl.x = -cl.w;
  });

  updateParticles();
}

function drawBackground(){
  ctx.fillStyle = "rgba(255,255,255,0.8)";
  clouds.forEach(cl=>{
    ctx.beginPath();
    ctx.ellipse(cl.x - cameraX*0.2, cl.y, cl.w, cl.w*0.6, 0, 0, 2*Math.PI);
    ctx.fill();
  });

  ctx.fillStyle = "#111";
  skyline.forEach(b=>{
    const x = b.x - cameraX*0.3;
    ctx.fillRect(x, b.y, b.w, b.h);
  });
}

function drawSpider(x,y){
  const faceDir = isSwinging ? (angularVelocity > 0 ? 1 : -1) : 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(faceDir, 1);
  ctx.translate(-x, -y);

  ctx.lineWidth=4; ctx.strokeStyle="#000"; ctx.fillStyle="#e30c0c";
  ctx.beginPath();
  ctx.arc(x, y-20,12,0,2*Math.PI); ctx.fill(); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x,y-10); ctx.lineTo(x,y+20);
  ctx.moveTo(x,y); ctx.lineTo(x-15,y+10);
  ctx.moveTo(x,y); ctx.lineTo(x+15,y+10);
  ctx.moveTo(x,y+20); ctx.lineTo(x-10,y+40);
  ctx.moveTo(x,y+20); ctx.lineTo(x+10,y+40);
  ctx.stroke();

  ctx.restore();
}

function drawRope(){
  const a=getAnchor();
  const ropeOffset = Math.sin(Date.now()*0.01) * 4;
  ctx.lineWidth=2; ctx.strokeStyle="#fff";
  ctx.beginPath();
  ctx.moveTo(a.x - cameraX, a.y);
  ctx.lineTo(spider.x - cameraX + ropeOffset, spider.y);
  ctx.stroke();
}

function drawBuildings(){
  anchors.forEach((a,i)=>{
    ctx.fillStyle = (i % 5 === 0) ? "#4cf" : "#222";
    ctx.fillRect(a.x - 25 - cameraX, a.y, 50, H - a.y);
  });
}

function draw(){
  ctx.clearRect(0,0,W,H);
  drawBackground();
  drawBuildings();
  drawParticles();
  if(isSwinging) drawRope();
  drawSpider(spider.x - cameraX, spider.y);
  scoreEl.textContent = "Score: " + score;
}

function loop(){
  update(); draw(); requestAnimationFrame(loop);
}

function attemptLatch(){
  const near = findNearestAnchor();
  if(near && near.dist < 200){
    anchorIndex = near.index;
    angle = Math.atan2(spider.x - near.anchor.x, spider.y - near.anchor.y);
    angularVelocity = 0;
    isSwinging = true;
    playWhoosh();
    createLatchParticles(spider.x, spider.y);
  }
}

["touchstart", "mousedown"].forEach(evt => {
  canvas.addEventListener(evt, ()=>{
    if(isSwinging) isHolding = true;
    else attemptLatch();
  });
});
["touchend", "mouseup"].forEach(evt => {
  canvas.addEventListener(evt, ()=>{
    if(isSwinging){
      isHolding = false;
      isSwinging = false;
      spider.vx = angularVelocity * ropeLength * Math.cos(angle + Math.PI/2);
      spider.vy = angularVelocity * ropeLength * Math.sin(angle + Math.PI/2);
    }
  });
});

resetGame();
loop();
</script>
</body>
</html>
